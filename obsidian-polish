#!/bin/bash
# Obsidian Note Polish Workflow
# Generates title + frontmatter and optionally inserts into file
#
# Usage:
#   obsidian-polish note.md                    # Edit file in-place (with backup)
#   obsidian-polish note.md --no-backup        # Edit without backup
#   obsidian-polish note.md --rename-file      # Rename file based on title
#   obsidian-polish note.md -o output.md       # Save to new file
#   cat note.md | obsidian-polish              # Pipe mode (stdout)
#   pbpaste | obsidian-polish                  # Clipboard mode

set -e
set -o pipefail

# Detect which fabric command is available
if command -v fabric-ai &> /dev/null; then
    FABRIC_CMD="fabric-ai"
elif command -v fabric &> /dev/null; then
    FABRIC_CMD="fabric"
else
    echo "Error: Neither 'fabric' nor 'fabric-ai' command found."
    echo "Please install fabric: https://github.com/danielmiessler/fabric"
    exit 1
fi

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ========== DATETIME CAPTURE ==========
# Captured at script start for consistency across all operations
SCRIPT_START_TIMESTAMP=$(date +%s)
SCRIPT_START_DATE=$(date '+%Y-%m-%d')
SCRIPT_START_DATETIME=$(date '+%Y-%m-%d %H:%M:%S')
SCRIPT_START_ISO=$(date -Iseconds)

# ========== CACHE CONFIGURATION ==========
# Central backup cache to avoid .bak file clutter
CACHE_DIR="${OBSIDIAN_POLISH_CACHE:-$HOME/.cache/obsidian-polish}"
BACKUPS_DIR="$CACHE_DIR/backups"
INDEX_FILE="$CACHE_DIR/index.txt"
CLEANUP_MARKER="$CACHE_DIR/.last_cleanup"

# ========== CATEGORY CONFIGURATION ==========
# Categories for intelligent filename prefixes

# CRITICAL: Bash version check (macOS has 3.2, needs 4.0+ for associative arrays)
BASH_MAJOR="${BASH_VERSION%%.*}"
if [ "$BASH_MAJOR" -lt 4 ]; then
    USE_ASSOC_ARRAYS=false
else
    USE_ASSOC_ARRAYS=true
fi

# Fallback functions for bash 3.x (case statements instead of arrays)
get_category_from_tag() {
    local tag=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    case "$tag" in
        development|coding|programming|dev) echo "dev" ;;
        meeting|call|discussion|standup) echo "meeting" ;;
        idea|brainstorm|concept) echo "idea" ;;
        task|todo|action) echo "task" ;;
        documentation|docs|reference) echo "doc" ;;
        research|analysis|investigation) echo "research" ;;
        personal|journal|diary) echo "personal" ;;
        *) echo "" ;;
    esac
}

matches_category_keywords() {
    local category="$1"
    local text="$2"
    case "$category" in
        dev) echo "$text" | grep -qiE "\\bcode\\b|\\bfunction\\b|\\bclass\\b|\\bbug\\b|\\bdebug\\b|\\bapi\\b|\\bgit\\b|\\bcommit\\b|\\bscript\\b|\\bdeploy\\b" ;;
        meeting) echo "$text" | grep -qiE "\\bmeeting\\b|\\bdiscussed\\b|\\bagenda\\b|\\battendees\\b|\\bminutes\\b|\\bcall\\b|\\bsync\\b" ;;
        idea) echo "$text" | grep -qiE "\\bidea\\b|\\bbrainstorm\\b|\\bconcept\\b|\\bvision\\b|\\bdream\\b" ;;
        task) echo "$text" | grep -qiE "\\btodo\\b|action item|\\btask\\b|\\bdeadline\\b|\\bcomplete\\b|\\bfinish\\b|\\bassign\\b" ;;
        doc) echo "$text" | grep -qiE "\\bdocumentation\\b|\\breference\\b|\\bguide\\b|\\btutorial\\b|how-to|\\bmanual\\b" ;;
        research) echo "$text" | grep -qiE "\\bresearch\\b|\\banalysis\\b|\\bfindings\\b|\\bstudy\\b|\\binvestigate\\b|\\bexplore\\b" ;;
        personal) echo "$text" | grep -qiE "\\bjournal\\b|\\breflection\\b|\\bpersonal\\b|\\bmood\\b|\\bdiary\\b" ;;
        *) return 1 ;;
    esac
}

# Default category when no match found
DEFAULT_CATEGORY="note"

# Helper functions
print_section() {
    echo -e "\n${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${BLUE}$1${NC}"
    echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

print_status() {
    echo -e "${CYAN}▶${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# Slugify function for filenames
slugify() {
    echo "$1" | iconv -t ascii//TRANSLIT | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | tr '[:upper:]' '[:lower:]'
}

# ========== CACHE MANAGEMENT FUNCTIONS ==========

# Initialize cache directory structure
init_cache_dir() {
    if [ ! -d "$BACKUPS_DIR" ]; then
        mkdir -p "$BACKUPS_DIR"
        print_status "Created cache directory: $CACHE_DIR"
    fi
    
    if [ ! -f "$INDEX_FILE" ]; then
        cat > "$INDEX_FILE" << 'EOF'
# Obsidian Polish Backup Index
# Format: timestamp|source_file|backup_file|operation|new_file
EOF
        print_status "Initialized cache index"
    fi
}

# Generate short hash for file path uniqueness
get_file_hash() {
    local filepath="$1"
    local abs_path=$(realpath "$filepath" 2>/dev/null || echo "$filepath")
    echo "$abs_path" | md5sum 2>/dev/null | cut -c1-6 || echo "$abs_path" | md5 2>/dev/null | cut -c1-6
}

# Backup file to central cache
backup_to_cache() {
    local input_file="$1"
    local operation="${2:-edit}"
    local new_file="${3:-}"  # Optional: for rename operations
    
    # Initialize cache if needed
    init_cache_dir
    
    # Generate backup filename
    local timestamp=$(echo "$SCRIPT_START_DATETIME" | tr ' :' '_')
    local hash=$(get_file_hash "$input_file")
    local basename=$(basename "$input_file" | tr '.' '-')
    local backup_filename="${timestamp}_${hash}_${basename}"
    local backup_path="$BACKUPS_DIR/$backup_filename"
    
    # Copy file to cache
    cp "$input_file" "$backup_path" 2>/dev/null || {
        print_warning "Backup failed, continuing anyway"
        return 1
    }
    
    # Append to index
    local abs_source=$(realpath "$input_file" 2>/dev/null || echo "$input_file")
    echo "${SCRIPT_START_ISO}|${abs_source}|${backup_filename}|${operation}|${new_file}" >> "$INDEX_FILE"
    
    # Trigger cleanup check (async, non-blocking)
    cleanup_cache &
    
    echo "$backup_path"
}

# Clean up old backups
cleanup_cache() {
    # Check if cleanup needed
    local file_count=$(find "$BACKUPS_DIR" -type f 2>/dev/null | wc -l)
    local last_cleanup=0
    
    if [ -f "$CLEANUP_MARKER" ]; then
        # macOS and Linux compatible stat
        last_cleanup=$(stat -c %Y "$CLEANUP_MARKER" 2>/dev/null || stat -f %m "$CLEANUP_MARKER" 2>/dev/null || echo 0)
    fi
    
    local now=$(date +%s)
    local age=$((now - last_cleanup))
    
    # Only cleanup if >100 files or >24h since last cleanup
    if [ "$file_count" -lt 100 ] && [ "$age" -lt 86400 ]; then
        return 0
    fi
    
    print_status "Running cache cleanup (background)..."
    
    # Remove files older than 30 days
    find "$BACKUPS_DIR" -type f -mtime +30 -delete 2>/dev/null
    
    # Per-file limit: keep last 10 backups per source file
    if [ -f "$INDEX_FILE" ]; then
        # Create temp file with entries to keep
        local temp_index=$(mktemp)
        
        # Copy header
        grep "^#" "$INDEX_FILE" > "$temp_index"
        
        # Process entries: sort by source file, then timestamp descending
        # Keep newest 10 per source file, delete older backups
        grep -v "^#" "$INDEX_FILE" | sort -t'|' -k2,2 -k1,1r | \
        awk -F'|' -v backups_dir="$BACKUPS_DIR" '
        {
            source = $2
            backup_file = $3
            count[source]++
            
            if (count[source] <= 10) {
                # Keep this entry
                print $0
            } else {
                # Delete the backup file
                system("rm -f \"" backups_dir "/" backup_file "\" 2>/dev/null")
            }
        }
        ' >> "$temp_index"
        
        mv "$temp_index" "$INDEX_FILE"
    fi
    
    # Update cleanup marker
    touch "$CLEANUP_MARKER"
}

# Add rename history to file as HTML comment
add_rename_history() {
    local file="$1"
    local old_name="$2"
    local new_name="$3"
    
    # Create history entry
    local history_entry="${SCRIPT_START_DATETIME}: $(basename "$old_name") → $(basename "$new_name")"
    
    # Check if file already has rename history
    if grep -q "<!-- rename-history" "$file" 2>/dev/null; then
        # Append to existing history (before closing -->)
        sed -i.tmp "s|-->|${history_entry}\n-->|" "$file"
        rm -f "${file}.tmp"
        print_status "Updated rename history"
    else
        # Add new history section
        cat >> "$file" << EOF

<!-- rename-history
${history_entry}
-->
EOF
        print_status "Added rename history"
    fi
}

# Extract tags from frontmatter (handles multiple YAML formats)
extract_tags_from_frontmatter() {
    local frontmatter="$1"
    local tags=""
    
    # Format 1: Inline array - tags: [tag1, tag2, tag3]
    if echo "$frontmatter" | grep -qE '^tags: *\['; then
        tags=$(echo "$frontmatter" | grep -E '^tags:' | \
            sed 's/^tags: *\[//; s/\].*$//' | \
            tr ',' '\n' | \
            sed 's/^[ "'"'"'#]*//; s/[ "'"'"']*$//' | \
            tr '\n' ' ')
    
    # Format 2: Single value - tags: tagname
    elif echo "$frontmatter" | grep -qE '^tags: *[a-zA-Z#]'; then
        tags=$(echo "$frontmatter" | grep -E '^tags:' | \
            sed 's/^tags: *//; s/^#//')
    
    # Format 3: Block format - tags:\n  - tag1\n  - tag2
    elif echo "$frontmatter" | grep -qE '^tags: *$'; then
        tags=$(echo "$frontmatter" | awk '
            /^tags:/ { capture=1; next }
            capture && /^  - / { gsub(/^  - /, ""); gsub(/^#/, ""); print }
            capture && /^[^ ]/ { exit }
        ' | tr '\n' ' ')
    fi
    
    # Normalize: lowercase, trim whitespace
    echo "$tags" | tr '[:upper:]' '[:lower:]' | xargs
}

# Detect category from tags, frontmatter, or content
detect_category() {
    local title="$1"
    local frontmatter="$2"
    local content="$3"
    
    # Priority 1: Check Obsidian tags in frontmatter
    if [ -n "$frontmatter" ]; then
        local tags=$(extract_tags_from_frontmatter "$frontmatter")
        
        # Check each tag against mapping
        for tag in $tags; do
            tag=$(echo "$tag" | xargs | tr '[:upper:]' '[:lower:]')
            
            local result=$(get_category_from_tag "$tag")
            if [ -n "$result" ]; then
                echo "$result"
                return 0
            fi
        done
    fi
    
    # Priority 2: Check frontmatter category field
    if [ -n "$frontmatter" ]; then
        local fm_category=$(echo "$frontmatter" | grep "^category:" | \
            sed 's/^category: *//g' | tr -d '"' | tr '[:upper:]' '[:lower:]' | xargs)
        if [ -n "$fm_category" ]; then
            # Validate it's a known category
            case "$fm_category" in
                dev|meeting|idea|task|doc|research|personal|note)
                    echo "$fm_category"
                    return 0
                    ;;
            esac
        fi
    fi
    
    # Priority 3: Keyword matching in title (highest weight)
    local title_lower=$(echo "$title" | tr '[:upper:]' '[:lower:]')
    for category in dev meeting idea task doc research personal; do
        if matches_category_keywords "$category" "$title_lower"; then
            echo "$category"
            return 0
        fi
    done
    
    # Priority 4: Keyword matching in content (lower weight, require 2+ matches)
    local content_lower=$(echo "$content" | head -50 | tr '[:upper:]' '[:lower:]')
    for category in dev meeting idea task doc research personal; do
        # Fallback: simplified matching (at least one strong match)
        if matches_category_keywords "$category" "$content_lower"; then
            echo "$category"
            return 0
        fi
    done
    
    # Priority 5: Default fallback
    echo "$DEFAULT_CATEGORY"
}

show_help() {
    echo -e "${BOLD}Obsidian Note Polish Workflow${NC}"
    echo ""
    echo "Usage:"
    echo "  ${BOLD}File Editing Mode:${NC}"
    echo "    obsidian-polish note.md                  # Edit in-place (creates backup)"
    echo "    obsidian-polish note.md -r               # Rename file based on title"
    echo "    obsidian-polish note.md -o output.md     # Save to new file"
    echo ""
    echo "  ${BOLD}Pipe Mode:${NC}"
    echo "    cat note.md | obsidian-polish            # Output to stdout + clipboard"
    echo "    pbpaste | obsidian-polish                # From clipboard"
    echo "    xclip -o | obsidian-polish               # From clipboard (Linux)"
    echo ""
    echo "Options:"
    echo "  -o, --output FILE       Save to different file"
    echo "  -r, --rename-file       Rename file based on generated title (slugified)"
    echo "  -c, --category CAT      Override category detection (dev|meeting|idea|task|doc|research|personal|note)"
    echo "  -t, --title-only        Generate only title"
    echo "  -f, --frontmatter-only  Generate only frontmatter"
    echo "  -y, --yes               Skip confirmation prompts"
    echo "  -h, --help              Show this help"
    echo ""
    echo "Modes:"
    echo "  ${BOLD}Default:${NC} Combined (title + frontmatter)"
    echo "  ${BOLD}--title-only:${NC} Uses obsidian_note_title pattern"
    echo "  ${BOLD}--frontmatter-only:${NC} Uses obsidian_frontmatter_gen pattern"
    echo ""
    echo "Examples:"
    echo "  obsidian-polish meeting-notes.md          # Smart edit with backup"
    echo "  obsidian-polish draft.md -r -y            # Edit, rename, no prompts"
    echo "  pbpaste | obsidian-polish                 # Review before applying"
    echo ""
    exit 0
}

# Parse arguments
INPUT_FILE=""
OUTPUT_FILE=""
MODE="combined"
AUTO_YES=false
EDIT_IN_PLACE=false
RENAME_FILE=false
CATEGORY_OVERRIDE=""

# Check if first argument is a file (file editing mode)
if [ $# -gt 0 ] && [ -f "$1" ]; then
    INPUT_FILE="$1"
    EDIT_IN_PLACE=true
    shift
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        -o|--output)
            OUTPUT_FILE="$2"
            EDIT_IN_PLACE=false
            shift 2
            ;;
        -r|--rename-file)
            RENAME_FILE=true
            shift
            ;;
        -c|--category)
            CATEGORY_OVERRIDE="$2"
            # Validate category
            case "$CATEGORY_OVERRIDE" in
                dev|meeting|idea|task|doc|research|personal|note)
                    ;;
                *)
                    print_error "Invalid category: $CATEGORY_OVERRIDE"
                    echo "Valid categories: dev, meeting, idea, task, doc, research, personal, note"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        -y|--yes)
            AUTO_YES=true
            shift
            ;;
        -t|--title-only)
            MODE="title-only"
            shift
            ;;
        -f|--frontmatter-only)
            MODE="frontmatter-only"
            shift
            ;;
        -h|--help)
            show_help
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

# Validate flag combinations
if [ "$RENAME_FILE" = true ] && [ -n "$OUTPUT_FILE" ]; then
    print_warning "--rename-file (-r) is ignored when using -o/--output"
fi

if [ "$RENAME_FILE" = true ] && [ "$MODE" = "frontmatter-only" ]; then
    print_warning "--rename-file (-r) requires title generation (ignored with -f/--frontmatter-only)"
fi

echo -e "${BOLD}${BLUE}╔════════════════════════════════════════╗${NC}"
echo -e "${BOLD}${BLUE}║   Obsidian Note Polish Workflow      ║${NC}"
echo -e "${BOLD}${BLUE}╚════════════════════════════════════════╝${NC}\n"

# Step 1: Get input
if [ -n "$INPUT_FILE" ]; then
    if [ ! -f "$INPUT_FILE" ]; then
        print_error "File not found: $INPUT_FILE"
        exit 1
    fi
    print_status "Reading from file: $INPUT_FILE"
    NOTE_CONTENT=$(cat "$INPUT_FILE")
elif [ -p /dev/stdin ]; then
    print_status "Reading from stdin..."
    NOTE_CONTENT=$(cat)
    EDIT_IN_PLACE=false
else
    print_error "No input provided."
    echo ""
    echo -e "${YELLOW}Usage:${NC}"
    echo -e "  ${DIM}obsidian-polish note.md${NC}        # Edit file"
    echo -e "  ${DIM}obsidian-polish note.md -r${NC}     # Edit + rename"
    echo -e "  ${DIM}cat note.md | obsidian-polish${NC}  # Pipe mode"
    echo -e "  ${DIM}pbpaste | obsidian-polish${NC}      # Clipboard"
    echo ""
    echo -e "${DIM}Use ${NC}${BOLD}obsidian-polish --help${NC}${DIM} for all options${NC}"
    echo ""
    exit 1
fi

# Validate input
if [ -z "$NOTE_CONTENT" ]; then
    print_error "Empty input received"
    exit 1
fi

print_success "Captured ${#NOTE_CONTENT} characters"

# Display preview
echo -e "\n${DIM}Preview:${NC}"
echo -e "${DIM}$(echo "$NOTE_CONTENT" | head -c 200)...${NC}\n"

# Step 2: Check if file already has frontmatter
HAS_FRONTMATTER=false
if echo "$NOTE_CONTENT" | head -1 | grep -q "^---$"; then
    HAS_FRONTMATTER=true
    print_warning "Note already has frontmatter"
    
    if [ "$EDIT_IN_PLACE" = true ] && [ "$AUTO_YES" = false ]; then
        echo -e "${YELLOW}Replace existing frontmatter? [y/N]:${NC} "
        read -r CONFIRM
        if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
            print_status "Cancelled by user"
            exit 0
        fi
    fi
fi

# Extract original created date if frontmatter exists (preserve for existing notes)
ORIGINAL_CREATED=""
if [ "$HAS_FRONTMATTER" = true ]; then
    ORIGINAL_CREATED=$(echo "$NOTE_CONTENT" | awk '
        /^---$/ { if (++dashes == 2) exit }
        dashes == 1 && /^created:/ { 
            sub(/^created: */, "")
            print
            exit 
        }
    ')
    if [ -n "$ORIGINAL_CREATED" ]; then
        print_status "Preserved original created date: $ORIGINAL_CREATED"
    fi
fi

# Step 3: Generate metadata
print_section "Generating Metadata"

case $MODE in
    "title-only")
        print_status "Running obsidian_note_title..."
        TEMP_FILE=$(mktemp)
        trap "rm -f $TEMP_FILE" EXIT
        
        echo "$NOTE_CONTENT" | $FABRIC_CMD -p obsidian_note_title > "$TEMP_FILE" 2>&1
        TITLE=$(cat "$TEMP_FILE")
        
        if [ -z "$TITLE" ]; then
            print_error "Title generation failed"
            exit 1
        fi
        
        print_success "Generated title: $TITLE"
        FRONTMATTER=""
        ;;
        
    "frontmatter-only")
        print_status "Running obsidian_frontmatter_gen..."
        TEMP_FILE=$(mktemp)
        trap "rm -f $TEMP_FILE" EXIT
        
        echo "$NOTE_CONTENT" | $FABRIC_CMD -p obsidian_frontmatter_gen > "$TEMP_FILE" 2>&1
        FRONTMATTER=$(cat "$TEMP_FILE")
        
        if [ -z "$FRONTMATTER" ]; then
            print_error "Frontmatter generation failed"
            exit 1
        fi
        
        print_success "Generated frontmatter"
        TITLE=""
        ;;
        
    "combined")
        print_status "Running obsidian_note_polish..."
        TEMP_FILE=$(mktemp)
        trap "rm -f $TEMP_FILE" EXIT
        
        echo "$NOTE_CONTENT" | $FABRIC_CMD -p obsidian_note_polish > "$TEMP_FILE" 2>&1
        RESULT=$(cat "$TEMP_FILE")
        
        if [ -z "$RESULT" ]; then
            print_error "Generation failed"
            exit 1
        fi
        
        # Parse the combined result
        TITLE=$(echo "$RESULT" | grep "^TITLE:" | sed 's/^TITLE: //')
        
        # Extract frontmatter (everything after "FRONTMATTER:" line until we find the closing ---)
        FRONTMATTER=$(echo "$RESULT" | awk '
            /^FRONTMATTER:/ { inFM=1; next }
            inFM { 
                if (/^---$/) {
                    if (seenFirstDashes) {
                        print $0
                        exit
                    }
                    seenFirstDashes=1
                }
                if (inFM) print $0
            }
        ')
        
        print_success "Generated title and frontmatter"
        ;;
esac

# ========== DETECT CATEGORY FOR RENAME ==========
# Detect category early so it's available for both filename and frontmatter
if [ "$RENAME_FILE" = true ]; then
    if [ -n "$CATEGORY_OVERRIDE" ]; then
        CATEGORY="$CATEGORY_OVERRIDE"
        print_status "Using override category: $CATEGORY"
    else
        CATEGORY=$(detect_category "$TITLE" "$FRONTMATTER" "$NOTE_CONTENT")
        print_status "Detected category: $CATEGORY"
    fi
fi

# ========== INJECT CONSISTENT DATETIME ==========
# Force script datetime over AI-generated date for consistency
if [ -n "$FRONTMATTER" ]; then
    if [ "$HAS_FRONTMATTER" = true ] && [ -n "$ORIGINAL_CREATED" ]; then
        # Existing note: preserve original created date, add modified field
        FRONTMATTER=$(echo "$FRONTMATTER" | sed "s|^created: .*|created: $ORIGINAL_CREATED|")
        # Add modified field before closing ---
        FRONTMATTER=$(echo "$FRONTMATTER" | awk -v date="$SCRIPT_START_DATE" '
            /^---$/ && NR > 1 { 
                print "modified: " date
                print
                next
            }
            { print }
        ')
        print_status "Preserved created: $ORIGINAL_CREATED, added modified: $SCRIPT_START_DATE"
    else
        # New note: use script date for created field
        if echo "$FRONTMATTER" | grep -q "^created:"; then
            # Replace AI-generated date with script date
            FRONTMATTER=$(echo "$FRONTMATTER" | sed "s|^created: .*|created: $SCRIPT_START_DATE|")
            print_status "New note, created: $SCRIPT_START_DATE"
        else
            # Add created field if missing (insert after opening ---)
            FRONTMATTER=$(echo "$FRONTMATTER" | awk -v date="$SCRIPT_START_DATE" '
                NR==1 { print; print "created: " date; next }
                { print }
            ')
            print_status "Added created field: $SCRIPT_START_DATE"
        fi
    fi
fi

# ========== INJECT CATEGORY ==========
# Add category to frontmatter if detected during rename
if [ -n "$FRONTMATTER" ] && [ "$RENAME_FILE" = true ] && [ -n "$CATEGORY" ]; then
    # Check if category field already exists
    if echo "$FRONTMATTER" | grep -q "^category:"; then
        # Replace existing category
        FRONTMATTER=$(echo "$FRONTMATTER" | sed "s|^category: .*|category: $CATEGORY|")
        print_status "Updated category in frontmatter: $CATEGORY"
    else
        # Add category field after created field (maintains logical field order)
        FRONTMATTER=$(echo "$FRONTMATTER" | awk -v cat="$CATEGORY" '
            /^created:/ { print; print "category: " cat; next }
            { print }
        ')
        print_status "Added category to frontmatter: $CATEGORY"
    fi
fi

# Step 4: Build the enhanced note
print_section "Building Enhanced Note"

ENHANCED_NOTE=""

# Add frontmatter if generated
if [ -n "$FRONTMATTER" ]; then
    ENHANCED_NOTE="$FRONTMATTER"
fi

# Remove existing frontmatter from original content if present
CLEAN_CONTENT="$NOTE_CONTENT"
if [ "$HAS_FRONTMATTER" = true ]; then
    # Remove everything from first --- to second --- (inclusive)
    CLEAN_CONTENT=$(echo "$NOTE_CONTENT" | awk '
        BEGIN { inFrontmatter=0; frontmatterDone=0; }
        /^---$/ { 
            if (!frontmatterDone) {
                inFrontmatter = !inFrontmatter;
                if (!inFrontmatter) {
                    frontmatterDone = 1;
                }
                next;
            }
        }
        !inFrontmatter && frontmatterDone { print }
    ')
fi

# Extract and preserve rename history if present
RENAME_HISTORY=""
if echo "$NOTE_CONTENT" | grep -q "<!-- rename-history"; then
    RENAME_HISTORY=$(echo "$NOTE_CONTENT" | awk '
        /<!-- rename-history/ { capture=1 }
        capture { print }
        /-->/ && capture { exit }
    ')
    # Remove rename history from CLEAN_CONTENT
    CLEAN_CONTENT=$(echo "$CLEAN_CONTENT" | awk '
        /<!-- rename-history/ { skip=1 }
        !skip { print }
        /-->/ && skip { skip=0; next }
    ')
fi

# Add title as H1 if generated and not already present
if [ -n "$TITLE" ]; then
    # Check if content already starts with H1
    # Pure bash: extract first line without subshell/pipe (avoids SIGPIPE on large content)
    FIRST_LINE="${CLEAN_CONTENT%%$'\n'*}"
    # Trim leading/trailing whitespace
    FIRST_LINE="${FIRST_LINE#"${FIRST_LINE%%[![:space:]]*}"}"
    FIRST_LINE="${FIRST_LINE%"${FIRST_LINE##*[![:space:]]}"}"
    if [[ "$FIRST_LINE" == "#"* ]]; then
        print_status "Replacing existing title"
        # Remove first line: everything after first newline
        CLEAN_CONTENT="${CLEAN_CONTENT#*$'\n'}"
    fi
    
    if [ -n "$ENHANCED_NOTE" ]; then
        ENHANCED_NOTE="${ENHANCED_NOTE}\n\n# ${TITLE}"
    else
        ENHANCED_NOTE="# ${TITLE}"
    fi
fi

# Add the clean content
if [ -n "$ENHANCED_NOTE" ]; then
    ENHANCED_NOTE="${ENHANCED_NOTE}\n\n${CLEAN_CONTENT}"
else
    ENHANCED_NOTE="$CLEAN_CONTENT"
fi

# Re-append preserved rename history if it existed
if [ -n "$RENAME_HISTORY" ]; then
    ENHANCED_NOTE="${ENHANCED_NOTE}\n\n${RENAME_HISTORY}"
fi

# Step 5: Output/Write
if [ "$EDIT_IN_PLACE" = true ]; then
    print_section "Editing File In-Place"
    
    # Create backup in cache (always, for safety)
    BACKUP_PATH=$(backup_to_cache "$INPUT_FILE" "edit")
    if [ -n "$BACKUP_PATH" ]; then
        print_success "Backup saved: $(basename "$BACKUP_PATH")"
        print_status "Cache location: $CACHE_DIR"
    else
        print_warning "Backup creation failed, but continuing"
    fi
    
    # Write enhanced content
    echo -e "$ENHANCED_NOTE" > "$INPUT_FILE"
    print_success "File updated: $INPUT_FILE"
    
    # Rename file if requested and we have a title
    if [ "$RENAME_FILE" = true ] && [ -n "$TITLE" ]; then
        # Category already detected earlier for frontmatter injection
        # Generate new filename with category prefix
        SLUGIFIED_TITLE=$(slugify "$TITLE")
        
        # Validate slugified title
        if [ -z "$SLUGIFIED_TITLE" ] || [ "$SLUGIFIED_TITLE" = "-" ]; then
            print_warning "Title cannot be converted to valid filename: '$TITLE'"
            print_status "Using timestamp-based name instead"
            SLUGIFIED_TITLE="note-$(date +%Y%m%d-%H%M%S)"
        fi
        
        # Truncate to prevent filesystem issues
        if [ ${#SLUGIFIED_TITLE} -gt 100 ]; then
            SLUGIFIED_TITLE="${SLUGIFIED_TITLE:0:100}"
            print_warning "Title truncated to 100 characters for filename"
        fi
        
        DIR_NAME=$(dirname "$INPUT_FILE")
        NEW_FILE="${DIR_NAME}/${CATEGORY}-${SLUGIFIED_TITLE}.md"
        
        # Check if target already exists
        if [ -f "$NEW_FILE" ] && [ "$NEW_FILE" != "$INPUT_FILE" ]; then
            print_warning "Target file already exists: $NEW_FILE"
            if [ "$AUTO_YES" = false ]; then
                echo -e "${YELLOW}Overwrite? [y/N]:${NC} "
                read -r CONFIRM
                if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
                    print_status "Rename cancelled"
                    NEW_FILE="$INPUT_FILE"
                fi
            else
                print_status "Overwriting existing file (auto-yes mode)"
            fi
        fi
        
        # Rename if different
        if [ "$NEW_FILE" != "$INPUT_FILE" ]; then
            # Save old filename for history
            OLD_FILE="$INPUT_FILE"
            
            # Perform rename
            mv "$INPUT_FILE" "$NEW_FILE"
            print_success "Renamed to: $NEW_FILE"
            
            # Add rename history to the file
            add_rename_history "$NEW_FILE" "$OLD_FILE" "$NEW_FILE"
            
            # Record rename in cache index (backup post-rename state)
            backup_to_cache "$NEW_FILE" "rename" "$NEW_FILE"
            
            INPUT_FILE="$NEW_FILE"
        fi
    fi
    
    # Show preview of changes
    echo -e "\n${DIM}Updated file preview:${NC}"
    head -20 "$INPUT_FILE"
    echo -e "${DIM}...${NC}\n"
    
elif [ -n "$OUTPUT_FILE" ]; then
    print_section "Writing to File"
    
    echo -e "$ENHANCED_NOTE" > "$OUTPUT_FILE"
    print_success "Saved to: $OUTPUT_FILE"
    
    echo -e "\n${DIM}Preview:${NC}"
    head -20 "$OUTPUT_FILE"
    echo -e "${DIM}...${NC}\n"
    
else
    # Pipe mode - output to stdout and clipboard
    print_section "RESULT"
    
    echo -e "$ENHANCED_NOTE"
    
    echo ""
    print_status "Copying to clipboard..."
    
    if command -v pbcopy &> /dev/null; then
        echo -e "$ENHANCED_NOTE" | pbcopy
        print_success "Copied to clipboard!"
    elif command -v xclip &> /dev/null; then
        echo -e "$ENHANCED_NOTE" | xclip -selection clipboard
        print_success "Copied to clipboard!"
    else
        print_warning "No clipboard utility found"
    fi
fi

echo -e "\n${BOLD}${GREEN}✨ Workflow complete!${NC}\n"
