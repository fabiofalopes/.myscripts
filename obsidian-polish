#!/bin/bash
# Obsidian Note Polish Workflow (Simplified)
# Generates title + frontmatter and optionally inserts into file
#
# Usage:
#   obsidian-polish note.md                    # Edit file in-place
#   obsidian-polish note.md --rename-file      # Rename file based on title
#   obsidian-polish note.md -o output.md       # Save to new file
#   cat note.md | obsidian-polish              # Pipe mode (stdout)

set -e
set -o pipefail

# Detect which fabric command is available
if command -v fabric-ai &> /dev/null; then
    FABRIC_CMD="fabric-ai"
elif command -v fabric &> /dev/null; then
    FABRIC_CMD="fabric"
else
    echo "Error: Neither 'fabric' nor 'fabric-ai' command found."
    echo "Please install fabric: https://github.com/danielmiessler/fabric"
    exit 1
fi

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ========== DATETIME CAPTURE ==========
SCRIPT_START_DATE=$(date '+%Y-%m-%d')
SCRIPT_START_DATETIME=$(date '+%Y-%m-%d %H:%M:%S')

# ========== CATEGORY CONFIGURATION ==========
get_category_from_tag() {
    local tag=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    case "$tag" in
        development|coding|programming|dev) echo "dev" ;;
        meeting|call|discussion|standup) echo "meeting" ;;
        idea|brainstorm|concept) echo "idea" ;;
        task|todo|action) echo "task" ;;
        documentation|docs|reference) echo "doc" ;;
        research|analysis|investigation) echo "research" ;;
        personal|journal|diary) echo "personal" ;;
        *) echo "" ;;
    esac
}

matches_category_keywords() {
    local category="$1"
    local text="$2"
    case "$category" in
        dev) echo "$text" | grep -qiE "\\bcode\\b|\\bfunction\\b|\\bclass\\b|\\bbug\\b|\\bdebug\\b|\\bapi\\b|\\bgit\\b|\\bcommit\\b|\\bscript\\b|\\bdeploy\\b" ;;
        meeting) echo "$text" | grep -qiE "\\bmeeting\\b|\\bdiscussed\\b|\\bagenda\\b|\\battendees\\b|\\bminutes\\b|\\bcall\\b|\\bsync\\b" ;;
        idea) echo "$text" | grep -qiE "\\bidea\\b|\\bbrainstorm\\b|\\bconcept\\b|\\bvision\\b|\\bdream\\b" ;;
        task) echo "$text" | grep -qiE "\\btodo\\b|action item|\\btask\\b|\\bdeadline\\b|\\bcomplete\\b|\\bfinish\\b|\\bassign\\b" ;;
        doc) echo "$text" | grep -qiE "\\bdocumentation\\b|\\breference\\b|\\bguide\\b|\\btutorial\\b|how-to|\\bmanual\\b" ;;
        research) echo "$text" | grep -qiE "\\bresearch\\b|\\banalysis\\b|\\bfindings\\b|\\bstudy\\b|\\binvestigate\\b|\\bexplore\\b" ;;
        personal) echo "$text" | grep -qiE "\\bjournal\\b|\\breflection\\b|\\bpersonal\\b|\\bmood\\b|\\bdiary\\b" ;;
        *) return 1 ;;
    esac
}

DEFAULT_CATEGORY="note"

# Helper functions
print_section() {
    echo -e "\n${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${BLUE}$1${NC}"
    echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

print_status() { echo -e "${CYAN}▶${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }

# Slugify function for filenames
slugify() {
    echo "$1" | iconv -t ascii//TRANSLIT | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | tr '[:upper:]' '[:lower:]'
}

# Extract tags from frontmatter
extract_tags_from_frontmatter() {
    local frontmatter="$1"
    local tags=""
    
    if echo "$frontmatter" | grep -qE '^tags: *\['; then
        tags=$(echo "$frontmatter" | grep -E '^tags:' | \
            sed 's/^tags: *\[//; s/\].*$//' | tr ',' '\n' | \
            sed 's/^[ "'"'"'#]*//; s/[ "'"'"']*$//' | tr '\n' ' ')
    elif echo "$frontmatter" | grep -qE '^tags: *[a-zA-Z#]'; then
        tags=$(echo "$frontmatter" | grep -E '^tags:' | sed 's/^tags: *//; s/^#//')
    elif echo "$frontmatter" | grep -qE '^tags: *$'; then
        tags=$(echo "$frontmatter" | awk '
            /^tags:/ { capture=1; next }
            capture && /^  - / { gsub(/^  - /, ""); gsub(/^#/, ""); print }
            capture && /^[^ ]/ { exit }
        ' | tr '\n' ' ')
    fi
    
    echo "$tags" | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Detect category from tags, frontmatter, or content
detect_category() {
    local title="$1"
    local frontmatter="$2"
    local content="$3"
    
    # Priority 1: Check Obsidian tags in frontmatter
    if [ -n "$frontmatter" ]; then
        local tags=$(extract_tags_from_frontmatter "$frontmatter")
        for tag in $tags; do
            tag=$(echo "$tag" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '[:upper:]' '[:lower:]')
            local result=$(get_category_from_tag "$tag")
            if [ -n "$result" ]; then
                echo "$result"
                return 0
            fi
        done
    fi
    
    # Priority 2: Check frontmatter category field
    if [ -n "$frontmatter" ]; then
        local fm_category=$(echo "$frontmatter" | grep "^category:" | \
            sed 's/^category: *//g' | tr -d '"' | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [ -n "$fm_category" ]; then
            case "$fm_category" in
                dev|meeting|idea|task|doc|research|personal|note)
                    echo "$fm_category"
                    return 0
                    ;;
            esac
        fi
    fi
    
    # Priority 3: Keyword matching in title
    local title_lower=$(echo "$title" | tr '[:upper:]' '[:lower:]')
    for category in dev meeting idea task doc research personal; do
        if matches_category_keywords "$category" "$title_lower"; then
            echo "$category"
            return 0
        fi
    done
    
    # Priority 4: Keyword matching in content
    local content_lower=$(echo "$content" | head -50 | tr '[:upper:]' '[:lower:]')
    for category in dev meeting idea task doc research personal; do
        if matches_category_keywords "$category" "$content_lower"; then
            echo "$category"
            return 0
        fi
    done
    
    echo "$DEFAULT_CATEGORY"
}

show_help() {
    echo -e "${BOLD}Obsidian Note Polish Workflow${NC}"
    echo ""
    echo "Usage:"
    echo "  ${BOLD}File Editing Mode:${NC}"
    echo "    obsidian-polish note.md                  # Edit in-place"
    echo "    obsidian-polish note.md -r               # Rename file based on title"
    echo "    obsidian-polish note.md -o output.md     # Save to new file"
    echo ""
    echo "  ${BOLD}Pipe Mode:${NC}"
    echo "    cat note.md | obsidian-polish            # Output to stdout + clipboard"
    echo "    pbpaste | obsidian-polish                # From clipboard"
    echo "    xclip -o | obsidian-polish               # From clipboard (Linux)"
    echo ""
    echo "Options:"
    echo "  -o, --output FILE       Save to different file"
    echo "  -r, --rename-file       Rename file based on generated title (slugified)"
    echo "  -c, --category CAT      Override category (dev|meeting|idea|task|doc|research|personal|note)"
    echo "  -t, --title-only        Generate only title"
    echo "  -f, --frontmatter-only  Generate only frontmatter"
    echo "  -y, --yes               Skip confirmation prompts"
    echo "  -h, --help              Show this help"
    echo ""
    echo "Examples:"
    echo "  obsidian-polish meeting-notes.md          # Edit file"
    echo "  obsidian-polish draft.md -r -y            # Edit, rename, no prompts"
    echo "  pbpaste | obsidian-polish                 # From clipboard"
    echo ""
    exit 0
}

# Parse arguments
INPUT_FILE=""
OUTPUT_FILE=""
MODE="combined"
AUTO_YES=false
EDIT_IN_PLACE=false
RENAME_FILE=false
CATEGORY_OVERRIDE=""

# Check if first argument is a file
if [ $# -gt 0 ] && [ -f "$1" ]; then
    INPUT_FILE="$1"
    EDIT_IN_PLACE=true
    shift
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        -o|--output)
            OUTPUT_FILE="$2"
            EDIT_IN_PLACE=false
            shift 2
            ;;
        -r|--rename-file)
            RENAME_FILE=true
            shift
            ;;
        -c|--category)
            CATEGORY_OVERRIDE="$2"
            case "$CATEGORY_OVERRIDE" in
                dev|meeting|idea|task|doc|research|personal|note) ;;
                *)
                    print_error "Invalid category: $CATEGORY_OVERRIDE"
                    echo "Valid: dev, meeting, idea, task, doc, research, personal, note"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        -y|--yes)
            AUTO_YES=true
            shift
            ;;
        -t|--title-only)
            MODE="title-only"
            shift
            ;;
        -f|--frontmatter-only)
            MODE="frontmatter-only"
            shift
            ;;
        -h|--help)
            show_help
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

# Validate flag combinations
if [ "$RENAME_FILE" = true ] && [ -n "$OUTPUT_FILE" ]; then
    print_warning "--rename-file (-r) is ignored when using -o/--output"
fi

if [ "$RENAME_FILE" = true ] && [ "$MODE" = "frontmatter-only" ]; then
    print_warning "--rename-file (-r) requires title generation (ignored with -f)"
fi

echo -e "${BOLD}${BLUE}╔════════════════════════════════════════╗${NC}"
echo -e "${BOLD}${BLUE}║   Obsidian Note Polish Workflow        ║${NC}"
echo -e "${BOLD}${BLUE}╚════════════════════════════════════════╝${NC}\n"

# Step 1: Get input
if [ -n "$INPUT_FILE" ]; then
    if [ ! -f "$INPUT_FILE" ]; then
        print_error "File not found: $INPUT_FILE"
        exit 1
    fi
    print_status "Reading from file: $INPUT_FILE"
    NOTE_CONTENT=$(cat "$INPUT_FILE")
elif [ -p /dev/stdin ]; then
    print_status "Reading from stdin..."
    NOTE_CONTENT=$(cat)
    EDIT_IN_PLACE=false
else
    print_error "No input provided."
    echo ""
    echo -e "${YELLOW}Usage:${NC}"
    echo -e "  ${DIM}obsidian-polish note.md${NC}        # Edit file"
    echo -e "  ${DIM}obsidian-polish note.md -r${NC}     # Edit + rename"
    echo -e "  ${DIM}cat note.md | obsidian-polish${NC}  # Pipe mode"
    echo ""
    exit 1
fi

if [ -z "$NOTE_CONTENT" ]; then
    print_error "Empty input received"
    exit 1
fi

print_success "Captured ${#NOTE_CONTENT} characters"
echo -e "\n${DIM}Preview:${NC}"
echo -e "${DIM}$(echo "$NOTE_CONTENT" | head -c 200)...${NC}\n"

# Step 2: Check for existing frontmatter
HAS_FRONTMATTER=false
if echo "$NOTE_CONTENT" | head -1 | grep -q "^---$"; then
    HAS_FRONTMATTER=true
    print_warning "Note already has frontmatter"
    
    if [ "$EDIT_IN_PLACE" = true ] && [ "$AUTO_YES" = false ]; then
        echo -e "${YELLOW}Replace existing frontmatter? [y/N]:${NC} "
        read -r CONFIRM
        if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
            print_status "Cancelled by user"
            exit 0
        fi
    fi
fi

# Extract original created date if exists
ORIGINAL_CREATED=""
if [ "$HAS_FRONTMATTER" = true ]; then
    ORIGINAL_CREATED=$(echo "$NOTE_CONTENT" | awk '
        /^---$/ { if (++dashes == 2) exit }
        dashes == 1 && /^created:/ { 
            sub(/^created: */, "")
            print
            exit 
        }
    ')
    if [ -n "$ORIGINAL_CREATED" ]; then
        print_status "Preserved original created date: $ORIGINAL_CREATED"
    fi
fi

# Step 3: Generate metadata
print_section "Generating Metadata"

case $MODE in
    "title-only")
        print_status "Running obsidian_note_title..."
        TEMP_FILE=$(mktemp)
        trap "rm -f $TEMP_FILE" EXIT
        
        echo "$NOTE_CONTENT" | $FABRIC_CMD -p obsidian_note_title > "$TEMP_FILE" 2>&1
        TITLE=$(cat "$TEMP_FILE")
        
        if [ -z "$TITLE" ]; then
            print_error "Title generation failed"
            exit 1
        fi
        
        print_success "Generated title: $TITLE"
        FRONTMATTER=""
        ;;
        
    "frontmatter-only")
        print_status "Running obsidian_frontmatter_gen..."
        TEMP_FILE=$(mktemp)
        trap "rm -f $TEMP_FILE" EXIT
        
        echo "$NOTE_CONTENT" | $FABRIC_CMD -p obsidian_frontmatter_gen > "$TEMP_FILE" 2>&1
        FRONTMATTER=$(cat "$TEMP_FILE")
        
        if [ -z "$FRONTMATTER" ]; then
            print_error "Frontmatter generation failed"
            exit 1
        fi
        
        print_success "Generated frontmatter"
        TITLE=""
        ;;
        
    "combined")
        print_status "Running obsidian_note_polish..."
        TEMP_FILE=$(mktemp)
        trap "rm -f $TEMP_FILE" EXIT
        
        echo "$NOTE_CONTENT" | $FABRIC_CMD -p obsidian_note_polish > "$TEMP_FILE" 2>&1
        RESULT=$(cat "$TEMP_FILE")
        
        if [ -z "$RESULT" ]; then
            print_error "Generation failed"
            exit 1
        fi
        
        TITLE=$(echo "$RESULT" | grep "^TITLE:" | sed 's/^TITLE: //')
        FRONTMATTER=$(echo "$RESULT" | awk '
            /^FRONTMATTER:/ { inFM=1; next }
            inFM { 
                if (/^---$/) {
                    if (seenFirstDashes) {
                        print $0
                        exit
                    }
                    seenFirstDashes=1
                }
                if (inFM) print $0
            }
        ')
        
        print_success "Generated title and frontmatter"
        ;;
esac

# Detect category for rename
if [ "$RENAME_FILE" = true ]; then
    if [ -n "$CATEGORY_OVERRIDE" ]; then
        CATEGORY="$CATEGORY_OVERRIDE"
        print_status "Using override category: $CATEGORY"
    else
        CATEGORY=$(detect_category "$TITLE" "$FRONTMATTER" "$NOTE_CONTENT")
        print_status "Detected category: $CATEGORY"
    fi
fi

# Inject consistent datetime
if [ -n "$FRONTMATTER" ]; then
    if [ "$HAS_FRONTMATTER" = true ] && [ -n "$ORIGINAL_CREATED" ]; then
        FRONTMATTER=$(echo "$FRONTMATTER" | sed "s|^created: .*|created: $ORIGINAL_CREATED|")
        FRONTMATTER=$(echo "$FRONTMATTER" | awk -v date="$SCRIPT_START_DATE" '
            /^---$/ && NR > 1 { 
                print "modified: " date
                print
                next
            }
            { print }
        ')
        print_status "Preserved created: $ORIGINAL_CREATED, added modified: $SCRIPT_START_DATE"
    else
        if echo "$FRONTMATTER" | grep -q "^created:"; then
            FRONTMATTER=$(echo "$FRONTMATTER" | sed "s|^created: .*|created: $SCRIPT_START_DATE|")
            print_status "New note, created: $SCRIPT_START_DATE"
        else
            FRONTMATTER=$(echo "$FRONTMATTER" | awk -v date="$SCRIPT_START_DATE" '
                NR==1 { print; print "created: " date; next }
                { print }
            ')
            print_status "Added created field: $SCRIPT_START_DATE"
        fi
    fi
fi

# Inject category into frontmatter
if [ -n "$FRONTMATTER" ] && [ "$RENAME_FILE" = true ] && [ -n "$CATEGORY" ]; then
    if echo "$FRONTMATTER" | grep -q "^category:"; then
        FRONTMATTER=$(echo "$FRONTMATTER" | sed "s|^category: .*|category: $CATEGORY|")
        print_status "Updated category in frontmatter: $CATEGORY"
    else
        FRONTMATTER=$(echo "$FRONTMATTER" | awk -v cat="$CATEGORY" '
            /^created:/ { print; print "category: " cat; next }
            { print }
        ')
        print_status "Added category to frontmatter: $CATEGORY"
    fi
fi

# Step 4: Build the enhanced note
print_section "Building Enhanced Note"

ENHANCED_NOTE=""

if [ -n "$FRONTMATTER" ]; then
    ENHANCED_NOTE="$FRONTMATTER"
fi

# Remove existing frontmatter from content
CLEAN_CONTENT="$NOTE_CONTENT"
if [ "$HAS_FRONTMATTER" = true ]; then
    CLEAN_CONTENT=$(echo "$NOTE_CONTENT" | awk '
        BEGIN { inFrontmatter=0; frontmatterDone=0; }
        /^---$/ { 
            if (!frontmatterDone) {
                inFrontmatter = !inFrontmatter;
                if (!inFrontmatter) {
                    frontmatterDone = 1;
                }
                next;
            }
        }
        !inFrontmatter && frontmatterDone { print }
    ')
fi

# Add title as H1 if generated
if [ -n "$TITLE" ]; then
    # Check if content already starts with H1 using pure bash (avoids subshell SIGPIPE issues)
    FIRST_LINE="${CLEAN_CONTENT%%$'\n'*}"
    FIRST_LINE="${FIRST_LINE#"${FIRST_LINE%%[![:space:]]*}"}"
    FIRST_LINE="${FIRST_LINE%"${FIRST_LINE##*[![:space:]]}"}"
    if [[ "$FIRST_LINE" == "#"* ]]; then
        print_status "Replacing existing title"
        # Remove first line: everything after first newline
        CLEAN_CONTENT="${CLEAN_CONTENT#*$'\n'}"
    fi
    
    if [ -n "$ENHANCED_NOTE" ]; then
        ENHANCED_NOTE="${ENHANCED_NOTE}\n\n# ${TITLE}"
    else
        ENHANCED_NOTE="# ${TITLE}"
    fi
fi

# Add the clean content
if [ -n "$ENHANCED_NOTE" ]; then
    ENHANCED_NOTE="${ENHANCED_NOTE}\n\n${CLEAN_CONTENT}"
else
    ENHANCED_NOTE="$CLEAN_CONTENT"
fi

# Step 5: Output/Write
if [ "$EDIT_IN_PLACE" = true ]; then
    print_section "Editing File In-Place"
    
    # Write enhanced content directly (no backup)
    echo -e "$ENHANCED_NOTE" > "$INPUT_FILE"
    print_success "File updated: $INPUT_FILE"
    
    # Rename file if requested
    if [ "$RENAME_FILE" = true ] && [ -n "$TITLE" ]; then
        SLUGIFIED_TITLE=$(slugify "$TITLE")
        
        if [ -z "$SLUGIFIED_TITLE" ] || [ "$SLUGIFIED_TITLE" = "-" ]; then
            print_warning "Title cannot be converted to valid filename: '$TITLE'"
            print_status "Using timestamp-based name instead"
            SLUGIFIED_TITLE="note-$(date +%Y%m%d-%H%M%S)"
        fi
        
        if [ ${#SLUGIFIED_TITLE} -gt 100 ]; then
            SLUGIFIED_TITLE="${SLUGIFIED_TITLE:0:100}"
            print_warning "Title truncated to 100 characters for filename"
        fi
        
        DIR_NAME=$(dirname "$INPUT_FILE")
        NEW_FILE="${DIR_NAME}/${CATEGORY}-${SLUGIFIED_TITLE}.md"
        
        # Check if target already exists
        if [ -f "$NEW_FILE" ] && [ "$NEW_FILE" != "$INPUT_FILE" ]; then
            print_warning "Target file already exists: $NEW_FILE"
            if [ "$AUTO_YES" = false ]; then
                echo -e "${YELLOW}Overwrite? [y/N]:${NC} "
                read -r CONFIRM
                if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
                    print_status "Rename cancelled"
                    NEW_FILE="$INPUT_FILE"
                fi
            else
                print_status "Overwriting existing file (auto-yes mode)"
            fi
        fi
        
        # Rename if different
        if [ "$NEW_FILE" != "$INPUT_FILE" ]; then
            mv "$INPUT_FILE" "$NEW_FILE"
            print_success "Renamed to: $NEW_FILE"
            INPUT_FILE="$NEW_FILE"
        fi
    fi
    
    # Show preview
    echo -e "\n${DIM}Updated file preview:${NC}"
    head -20 "$INPUT_FILE"
    echo -e "${DIM}...${NC}\n"
    
elif [ -n "$OUTPUT_FILE" ]; then
    print_section "Writing to File"
    
    echo -e "$ENHANCED_NOTE" > "$OUTPUT_FILE"
    print_success "Saved to: $OUTPUT_FILE"
    
    echo -e "\n${DIM}Preview:${NC}"
    head -20 "$OUTPUT_FILE"
    echo -e "${DIM}...${NC}\n"
    
else
    # Pipe mode
    print_section "RESULT"
    
    echo -e "$ENHANCED_NOTE"
    
    echo ""
    print_status "Copying to clipboard..."
    
    if command -v pbcopy &> /dev/null; then
        echo -e "$ENHANCED_NOTE" | pbcopy
        print_success "Copied to clipboard!"
    elif command -v xclip &> /dev/null; then
        echo -e "$ENHANCED_NOTE" | xclip -selection clipboard
        print_success "Copied to clipboard!"
    else
        print_warning "No clipboard utility found"
    fi
fi

echo -e "\n${BOLD}${GREEN}✨ Done!${NC}\n"
